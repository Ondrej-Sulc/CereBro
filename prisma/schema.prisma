// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

// --- Enums for type safety and consistency ---
enum ChampionClass {
  SCIENCE
  SKILL
  MYSTIC
  COSMIC
  TECH
  MUTANT
  SUPERIOR
}

enum AbilityLinkType {
  ABILITY
  IMMUNITY
}

// NEW: Enum for the different attack types.
enum AttackType {
  L1
  L2
  L3
  L4
  M1
  M2
  H
  S1
  S2
}

enum WarResult {
  WIN
  LOSS
  UNKNOWN
}

enum WarVideoStatus {
  PLANNING
  UPLOADED
  PUBLISHED
  REJECTED
}

enum WarStatus {
  PLANNING
  FINISHED
}

enum WarMapType {
  STANDARD
  BIG_THING
}

enum DuelStatus {
  ACTIVE
  SUGGESTED
  OUTDATED
  ARCHIVED
}

enum DuelSource {
  USER_SUGGESTION
  GUIA_MTC
  COCPIT
  MCOCHUB
}

enum BotJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum BotJobType {
  NOTIFY_WAR_VIDEO
  NOTIFY_DEATH_VIDEO
  DISTRIBUTE_WAR_PLAN
  UPDATE_MEMBER_ROLES
}

// --- Models ---

// RENAMED from GlossaryCategory and re-linked
model AbilityCategory {
  id          Int    @id @default(autoincrement())
  name        String @unique
  description String

  abilities Ability[]
}

model Ability {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String?
  emoji       String?

  categories AbilityCategory[]
  champions  ChampionAbilityLink[]
}

model Champion {
  id            Int           @id @default(autoincrement())
  name          String        @unique
  shortName     String
  class         ChampionClass
  releaseDate   DateTime
  obtainable    String[]
  images        Json
  discordEmoji  String?
  fullAbilities Json

  // --- Relations ---
  tags               Tag[]
  abilities          ChampionAbilityLink[]
  attacks            Attack[]
  prestigeData       ChampionPrestige[]
  roster             Roster[]
  synergyProviderFor ChampionAbilitySynergy[]
  duels              Duel[]
  asAttacker         WarFight[]               @relation("AttackerRelation")
  asDefender         WarFight[]               @relation("DefenderRelation")
  defensePlacements  WarDefensePlacement[]
  placedPrefights    FightPrefight[]
  extraAssignments   WarExtraChampion[]
  seasonBans         SeasonBan[]
  warBans            WarBan[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ChampionPrestige {
  id          Int      @id @default(autoincrement())
  championId  Int
  champion    Champion @relation(fields: [championId], references: [id], onDelete: Cascade)
  rarity      Int
  rank        Int
  sig         Int
  prestige    Int

  @@unique([championId, rarity, rank, sig])
  @@index([championId])
}

model Duel {
  id                   Int        @id @default(autoincrement())
  playerName           String
  rank                 String?
  source               DuelSource @default(GUIA_MTC)
  status               DuelStatus @default(ACTIVE) // Tracks the state of the duel target
  // To track who submitted the suggestion/report
  submittedByDiscordId String?

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Prevent duplicate suggestions for the same champion and player
  @@unique([championId, playerName])
  @@index([championId])
}

model Tag {
  id       Int    @id @default(autoincrement())
  name     String
  category String

  champions Champion[]

  attackTactics  WarTactic[] @relation("AttackTactic")
  defenseTactics WarTactic[] @relation("DefenseTactic")

  highlightedInPlans WarDefensePlan[]

  @@unique([name, category])
}

model ChampionAbilityLink {
  id     Int             @id @default(autoincrement())
  type   AbilityLinkType
  source String?

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  abilityId Int
  ability   Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  synergyChampions ChampionAbilitySynergy[]

  @@unique([championId, abilityId, type, source])
  @@index([championId])
  @@index([abilityId])
}

model ChampionAbilitySynergy {
  id                    Int                 @id @default(autoincrement())
  championAbilityLinkId Int
  championAbilityLink   ChampionAbilityLink @relation(fields: [championAbilityLinkId], references: [id], onDelete: Cascade)
  championId            Int
  champion              Champion            @relation(fields: [championId], references: [id], onDelete: Cascade)

  @@unique([championAbilityLinkId, championId])
  @@index([championAbilityLinkId])
  @@index([championId])
}

// --- New Models for Normalized Attacks ---

// Represents a specific attack for a champion (e.g., Abomination's SP2)
model Attack {
  id   Int        @id @default(autoincrement())
  type AttackType // e.g., S1, M2, etc.

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  hits Hit[] // An attack is composed of one or more hits

  @@unique([championId, type]) // Each champion can only have one S1, one M1, etc.
  @@index([championId])
}

// Represents a single hit within an attack.
model Hit {
  id         Int      @id @default(autoincrement())
  properties String[] // e.g., ["Contact", "Physical"]

  attackId Int
  attack   Attack @relation(fields: [attackId], references: [id], onDelete: Cascade)

  @@index([attackId])
}

enum ScheduleFrequency {
  daily
  weekly
  monthly
  every
}

model Schedule {
  id                String            @id @default(cuid())
  name              String
  frequency         ScheduleFrequency
  time              String
  command           String?
  message           String?
  target_channel_id String?
  target_user_id    String?
  is_active         Boolean           @default(true)
  day               String?
  interval          String?
  unit              String?
  last_run          DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AQState {
  channelId String   @id
  state     Json
  updatedAt DateTime @updatedAt
}

// --- Player and Prestige Logging ---

model BotUser {
  id              String   @id @default(cuid())
  discordId       String   @unique
  isBotAdmin      Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  profiles        Player[]
  activeProfileId String?
}

model Player {
  id                String  @id @default(cuid())
  discordId         String
  ingameName        String
  avatar            String?
  isActive          Boolean @default(false)
  timezone          String?
  isTrustedUploader Boolean @default(false)

  summonerPrestige Int?
  championPrestige Int?
  relicPrestige    Int?
  isBotAdmin       Boolean @default(false) // Deprecated: Use BotUser.isBotAdmin
  isOfficer        Boolean @default(false)
  battlegroup      Int?

  botUserId String?
  botUser   BotUser? @relation(fields: [botUserId], references: [id], onDelete: Cascade)

  roster          Roster[]
  prestigeHistory PrestigeLog[]
  uploadTokens    UploadToken[]

  alliance   Alliance? @relation(fields: [allianceId], references: [id], onDelete: SetNull)
  allianceId String?

  membershipRequests AllianceMembershipRequest[] @relation("PlayerRequests")
  sentInvitations    AllianceMembershipRequest[] @relation("OfficerInvites")

  playedInFights  WarFight[]         @relation("PlayerInFight")
  defensePlacements WarDefensePlacement[]
  submittedVideos WarVideo[]         @relation("SubmittedBy")
  placedPrefights FightPrefight[]
  extraChampions  WarExtraChampion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([discordId, ingameName])
  @@index([discordId])
  @@index([allianceId])
}

model PrestigeLog {
  id               Int      @id @default(autoincrement())
  summonerPrestige Int
  championPrestige Int
  relicPrestige    Int
  createdAt        DateTime @default(now())

  player   Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  playerId String

  @@index([playerId])
}

model Alliance {
  id                     String   @id @default(cuid())
  guildId                String?  @unique
  name                   String
  enabledFeatureCommands String[] @default([])
  createAqThread         Boolean  @default(false)
  canUploadFiles         Boolean  @default(false)
  officerRole            String?
  battlegroup1Role       String?
  battlegroup2Role       String?
  battlegroup3Role       String?
  warVideosChannelId     String?
  deathChannelId         String?
  battlegroup1ChannelId  String?
  battlegroup2ChannelId  String?
  battlegroup3ChannelId  String?

  battlegroup1Color      String   @default("#ef4444") // Red
  battlegroup2Color      String   @default("#22c55e") // Green
  battlegroup3Color      String   @default("#3b82f6") // Blue

  linkCode               String?  @unique
  linkCodeExpires        DateTime?

  members            Player[]
  config             AllianceConfig?
  aqSchedules        AQSchedule[]
  aqSkip             AQSkip?
  aqReminderSettings AQReminderSettings?
  wars               War[]
  defensePlans       WarDefensePlan[]
  membershipRequests AllianceMembershipRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum MembershipRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum MembershipRequestType {
  INVITE // Officer invites player
  REQUEST // Player requests to join
}

model AllianceMembershipRequest {
  id         String                  @id @default(cuid())
  status     MembershipRequestStatus @default(PENDING)
  type       MembershipRequestType
  
  allianceId String
  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)

  playerId   String
  player     Player   @relation("PlayerRequests", fields: [playerId], references: [id], onDelete: Cascade)

  // Who sent the invite (if type is INVITE)
  inviterId  String?
  inviter    Player?  @relation("OfficerInvites", fields: [inviterId], references: [id], onDelete: SetNull)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([allianceId])
  @@index([playerId])
}

model AQReminderSettings {
  id         String   @id @default(cuid())
  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId String   @unique

  section1ReminderEnabled Boolean @default(true)
  section1PingTime        String  @default("11:00")

  section2ReminderEnabled Boolean @default(true)
  section2PingTime        String  @default("18:00")

  finalReminderEnabled Boolean @default(true)
  finalPingTime        String  @default("11:00")
}

model AllianceConfig {
  id      String  @id @default(cuid())
  sheetId String?

  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId String   @unique
}

model AQSchedule {
  id          String   @id @default(cuid())
  alliance    Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId  String
  battlegroup Int
  dayOfWeek   Int // 0 = Sunday, 6 = Saturday
  time        String // "HH:mm"
  aqDay       Int
  channelId   String
  roleId      String

  @@unique([allianceId, battlegroup, aqDay])
}

model AQSkip {
  id         String   @id @default(cuid())
  alliance   Alliance @relation(fields: [allianceId], references: [id], onDelete: Cascade)
  allianceId String   @unique
  skipUntil  DateTime
}

model Roster {
  id          String  @id @default(cuid())
  stars       Int
  rank        Int
  isAwakened  Boolean
  isAscended  Boolean @default(false)
  powerRating Int?
  sigLevel    Int     @default(0)

  player     Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  playerId   String
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)
  championId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([playerId, championId, stars])
  @@index([playerId])
  @@index([championId])
}

// --- War Video Models ---

model War {
  id            String    @id @default(cuid())
  name          String?
  season        Int
  warNumber     Int?
  warTier       Int
  enemyAlliance String?
  status        WarStatus @default(PLANNING)
  result        WarResult @default(UNKNOWN)
  enemyDeaths   Int?
  mapType       WarMapType @default(STANDARD)
  createdAt     DateTime  @default(now())

  // A war belongs to an alliance
  allianceId String
  alliance   Alliance @relation(fields: [allianceId], references: [id])

  // A war is comprised of many fights
  fights         WarFight[]
  extraChampions WarExtraChampion[]
  bans           WarBan[]

  @@unique([allianceId, season, warNumber])
  @@index([allianceId])
}

model WarDefensePlan {
  id          String     @id @default(cuid())
  name        String
  mapType     WarMapType @default(STANDARD)
  tier        Int?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  allianceId  String
  alliance    Alliance   @relation(fields: [allianceId], references: [id], onDelete: Cascade)

  placements  WarDefensePlacement[]
  
  // Optional: Link to a specific tactic for visualization
  tacticId    String?
  tactic      WarTactic? @relation(fields: [tacticId], references: [id])

  highlightTagId Int?
  highlightTag   Tag? @relation(fields: [highlightTagId], references: [id])

  @@index([allianceId])
}

model WarDefensePlacement {
  id          String   @id @default(cuid())
  
  nodeId      Int
  node        WarNode  @relation(fields: [nodeId], references: [id])

  defenderId  Int?
  defender    Champion? @relation(fields: [defenderId], references: [id])

  playerId    String?
  player      Player?   @relation(fields: [playerId], references: [id])

  planId      String
  plan        WarDefensePlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  battlegroup Int @default(1)
  starLevel   Int? // New: Star level of the champion placed

  @@unique([planId, battlegroup, nodeId])
  @@index([planId])
  @@index([playerId])
  @@index([defenderId])
  @@index([nodeId])
}

model SeasonBan {
  id      String @id @default(cuid())
  season  Int
  minTier Int?
  maxTier Int?

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([season, minTier, maxTier, championId])
}

model WarBan {
  id String @id @default(cuid())

  warId String
  war   War    @relation(fields: [warId], references: [id], onDelete: Cascade)

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([warId])
  @@index([championId])
}

model WarFight {
  id          String   @id @default(cuid())
  death       Int      @default(0)
  battlegroup Int
  createdAt   DateTime @default(now())

  // --- Core Fight Details ---
  attackerId Int?
  attacker   Champion? @relation("AttackerRelation", fields: [attackerId], references: [id])
  defenderId Int?
  defender   Champion? @relation("DefenderRelation", fields: [defenderId], references: [id])
  nodeId     Int
  node       WarNode   @relation(fields: [nodeId], references: [id])

  prefightChampions FightPrefight[]

  // --- Contextual Links ---
  // The player who performed the fight
  playerId String?
  player   Player? @relation("PlayerInFight", fields: [playerId], references: [id])

  // The war this fight belongs to
  warId String
  war   War    @relation(fields: [warId], references: [id], onDelete: Cascade)

  // Optional notes for the fight
  notes String?

  // The video this fight appears in (optional, can be null)
  videoId String?
  video   WarVideo? @relation(fields: [videoId], references: [id], onDelete: SetNull)

  @@index([attackerId])
  @@index([defenderId])
  @@index([nodeId])
  @@index([playerId])
  @@index([warId])
  @@index([videoId])
}

model FightPrefight {
  id String @id @default(cuid())

  warFightId String
  warFight   WarFight @relation(fields: [warFightId], references: [id], onDelete: Cascade)

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  playerId String?
  player   Player? @relation(fields: [playerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([warFightId, championId])
  @@index([warFightId])
  @@index([championId])
  @@index([playerId])
}

model WarExtraChampion {
  id String @id @default(cuid())

  warId String
  war   War    @relation(fields: [warId], references: [id], onDelete: Cascade)

  playerId String
  player   Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  championId Int
  champion   Champion @relation(fields: [championId], references: [id], onDelete: Cascade)

  battlegroup Int

  createdAt DateTime @default(now())

  @@index([warId])
  @@index([playerId])
}

model WarVideo {
  id          String         @id @default(cuid())
  gcsUrl      String?        @unique
  url         String?        @unique
  description String?
  visibility  String         @default("public")
  status      WarVideoStatus @default(PLANNING)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // A video can contain one or more fights
  fights WarFight[]

  // The player who submitted the video
  submittedById String
  submittedBy   Player @relation("SubmittedBy", fields: [submittedById], references: [id])

  @@index([submittedById])
}

model WarNode {
  id          Int                 @id @default(autoincrement())
  nodeNumber  Int                 @unique
  description String?
  fights      WarFight[]
  allocations WarNodeAllocation[]
  placements  WarDefensePlacement[]
}

model NodeModifier {
  id          String @id @default(cuid())
  name        String
  description String

  allocations WarNodeAllocation[]

  @@unique([name, description])
}

model WarNodeAllocation {
  id        String  @id @default(cuid())
  warNodeId Int
  warNode   WarNode @relation(fields: [warNodeId], references: [id], onDelete: Cascade)

  nodeModifierId String
  nodeModifier   NodeModifier @relation(fields: [nodeModifierId], references: [id], onDelete: Cascade)

  minTier Int?
  maxTier Int?
  season  Int?
  mapType WarMapType @default(STANDARD)

  @@index([warNodeId])
  @@index([nodeModifierId])
}

model WarTactic {
  id      String @id @default(cuid())
  season  Int
  minTier Int?
  maxTier Int?

  attackTagId Int?
  attackTag   Tag? @relation("AttackTactic", fields: [attackTagId], references: [id])

  defenseTagId Int?
  defenseTag   Tag? @relation("DefenseTactic", fields: [defenseTagId], references: [id])

  name String?

  defensePlans WarDefensePlan[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([season, minTier, maxTier])
}

model UploadSession {
  id        String   @id @default(cuid())
  token     String   @unique
  fightIds  String[]
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model UploadToken {
  id        String   @id @default(cuid())
  token     String   @unique
  playerId  String
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([playerId])
}

// --- NextAuth Models ---

model SystemConfig {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model BotJob {
  id        String       @id @default(cuid())
  type      BotJobType
  status    BotJobStatus @default(PENDING)
  payload   Json
  error     String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}